22/03/16/수

<h1>같은 숫자는 싫어</h1>

<strong>문제 설명</strong>  
배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면,

- arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.
- arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.
  배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.

<br>

<strong>제한사항</strong>

- 배열 arr의 크기 : `1,000,000 이하의 자연수`
- 배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수

<br>  
<strong>입출력 예</strong>

| arr             | answer    |
| --------------- | --------- |
| [1,1,3,3,0,1,1] | [1,3,0,1] |
| [4,4,4,3,3]     | [4,3]     |

<br>  
<strong>입출력 예 설명</strong>

- 입출력 예 #1,2  
  문제의 예시와 같습니다.

<br>
<br>

<h1>풀이</h1>
<h3>내가 푼 풀이</h3>

```javascript
function solution(arr) {
  let answer = [];

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] != arr[i + 1]) {
      answer.push(arr[i]);
    }
  }
  return answer;
}
```

: for문으로 앞 인덱스와 뒤 인덱스를 비교해서 수가 다를 경우에만 새로운 answer 배열에 `추가하는 방법`å으로 풀었다.

```javascript
function solution(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] == arr[i + 1]) {
      arr.splice(i, 1);
      i += -1;
    }
  }
  return arr;
}
```

: 배열을 삭제하면서 풀 경우 효율성 테스트에서 오류가 났는데, 이렇게 배열을 삭제할 경우에는,

> 해당 원소의 뒤 원소부터 차례대로 앞으로 당기는 작업을 하게 된다. 예를 들어 1,000,000 크기의 배열에서 맨 앞 원소를 제거하면 999,999번의 이동 작업을 수행하게 됩니다.  
> 이 문제에서 `배열의 최대 길이는 1,000,000이라는 조건`이 있었고, 최악의 경우 1,000,000 + 999,999 + 999,998 + 999,997 + ... = 500,000,500,000
> 약 5천억 번 연산을 하게 되며, 1억번의 연산에 1초가 걸린다는 가정하에 1시간 22분이 걸립니다.

<br>
<h3>다른 사람 풀이</h3>

```javascript
function solution(arr) {
  return arr.filter((val, index) => val != arr[index + 1]);
}
```

<br>
<br>

<h3>참고 </h3>

- filter
